/*
 * anchor.cpp
 *
 *  Created on: May 30, 2016
 *      Author: sdcr
 */

#include "anchor.h";

#define ANCHOR_ADDR 0x76
#define ANCHOR_RESET 0x1E
#define ANCHOR_ADC_READ 0x00
#define ANCHOR_PROM_READ 0xA0
#define ANCHOR_CONVERT_D1_8192 0x4A
#define ANCHOR_CONVERT_D2_8192 0x5A

I2Cdev i2cdev;



Anchor::Anchor(){
	fluidDensity = 1029;
}

void Anchor::init(){

	i2cdev.writeByte(ANCHOR_ADDR, ANCHOR_RESET, 0);
	usleep(1000);

	for(uint8_t i = 0 ; i < 8; i++){

		i2cdev.readByte(ANCHOR_ADDR, ANCHOR_PROM_READ + i * 2, C[i]);

	}

	uint8_t crcRead = C[0] >> 12;
	uint8_t crcCalculated = crc4(C);

}

void Anchor::read(){

}

void Anchor::readTestCase(){

}

float Anchor::altitude(){

}

float Anchor::depth(){

}

void Anchor::setFluidDensity(float density){

}

float Anchor::temperature(){

}

uint8_t Anchor::crc4(uint16_t n_prom[]) {
	uint16_t n_rem = 0;

	n_prom[0] = ((n_prom[0]) & 0x0FFF);
	n_prom[7] = 0;

	for ( uint8_t i = 0 ; i < 16; i++ ) {
		if ( i%2 == 1 ) {
			n_rem ^= (uint16_t)((n_prom[i>>1]) & 0x00FF0);
		} else {
			n_rem ^= (uint16_t)(n_prom[i>>1] >> 8);
		}
		for ( uint8_t n_bit = 8 ; n_bit > 0 ; n_bit-- ) {
			if ( n_rem & 0x8000 ) {
				n_rem = (n_rem << 1) ^ 0x3000;
			} else {
				n_rem = (n_rem << 1);
			}
		}
	}

	n_rem = ((n_rem >> 12) & 0x000F);

	return n_rem ^ 0x00;
}
